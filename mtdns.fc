;; Lib stuff
;; to lib

;; XXX: autokeylen
(slice, int) dict_get?(cell dict, int key_len, slice key) asm(key dict key_len) "DICTGET" "NULLSWAPIFNOT";
builder store_zeroes(builder b, int len) asm "STZEROES";

;; XXX: try DICTUSET instead of DICTUSETB


;; helpers

;; workaround for variable keylen dict bugs
slice rpad(slice str) {
  return begin_cell()
    .store_slice(str)
    .store_zeroes( 32 * 8 - slice_bits(str) )
    .end_cell()
    .begin_parse();
}

;; Manual Ton DNS

() recv_internal(slice in_msg) impure {
  ;; do nothing for internal messages
}

() recv_external(slice in_msg) impure {

  var op = in_msg~load_uint(32);
  throw_if(35, op != 1);

  var cat_id = in_msg~load_int(16);
  var rec_value = in_msg~load_uint(256);
  var str_slc = rpad(in_msg);

  var cs = get_data().begin_parse();
  var records = cs~load_dict();
  cs.end_parse();

  var (cat_slice, found) = records.dict_get?(slice_bits(str_slc), str_slc);
  var record_cats = found ? cat_slice~load_dict() : new_dict();
  record_cats~idict_set_builder(16, cat_id, begin_cell().store_uint(rec_value, 256));
  records~dict_set_builder(slice_bits(str_slc), str_slc, begin_cell().store_dict(record_cats));

  set_data(begin_cell().store_dict(records).end_cell());
  accept_message();
}


;; Get methods

(int, cell) dnsresolve(int cat_id, slice in_req) method_id {

  var cs = get_data().begin_parse();
  var records = cs~load_dict();
  cs.end_parse();

  var req = rpad(in_req);

  var (cat_slice, found) = records.dict_get?(slice_bits(req), req);
  if (found) {
    var record_cats = cat_slice~load_dict();
    var (rec, cat_found) = record_cats.idict_get?(16, cat_id);
    if (cat_found) {
      var res = rec~load_uint(256);
      return (res, begin_cell().store_uint(res, 256).end_cell());
    }
  } else {
    ;; workaroung for noreturn marking bug
    return (0, begin_cell().end_cell());
  }

  return (0, begin_cell().end_cell());
}
